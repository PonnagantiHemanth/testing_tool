#!/usr/bin/env python
# -*- coding: utf-8 -*-
# ------------------------------------------------------------------------------
# Python Test Harness
# ------------------------------------------------------------------------------
"""
@package copydocreplacer

@brief Replacement of the copydoc tag in python scripts

@author christophe.roquebert

@date   2018/07/30
"""
# ------------------------------------------------------------------------------
# imports
# ------------------------------------------------------------------------------
from pickle import dump
from pickle import load
from glob import glob
from argparse import ArgumentParser
from os import makedirs
from os import walk
from os.path import abspath
from os.path import basename
from os.path import exists
from os.path import isdir
from os.path import isfile
from os.path import join
from os.path import normpath
from time import strftime

import sys
import re

from pylibrary.tools.importutils import importFqn  # pylint:disable=E0611,F0401


# ----------------------------------------------------------------------------
# implementation
# ----------------------------------------------------------------------------

class Filter(object):
    """
    Doxygen filter for Python
    """

    # @name Properties (Application Name, Description, Version)
    # @{
    _NAME = 'copydocreplacer'
    _BRIEF = 'Replacer for @copydoc tags'
    _VERSION = '0.5.1.0'
    # @}

    def filterDir(self, src_dir, dst_dir, exclude=None, recursive=False):
        """
        Filter [recursively] a directory

        @param  src_dir    [in] (str)  SRC directory
        @param  dst_dir    [in] (str)  DST directory
        @param  exclude   [in] (list) PATTERN
        @param  recursive [in] (bool) Flag
        """
        if exclude is None:
            exclude = list()
        # end if

        if '.svn' not in exclude:
            exclude.append('.svn')
        # end if

        if 'CVS' not in exclude:
            exclude.append('CVS')
        # end if

        for src_path, dir_names, file_names in walk(src_dir):

            for pattern in exclude:
                for name in glob(join(src_path, pattern)):
                    if isdir(name):
                        dir_names.remove(basename(name))
                    elif isfile(name):
                        file_names.remove(basename(name))
                    # end if
                # end for
            # end for

            dst_path = src_path.replace(src_dir, dst_dir)

            if not isdir(dst_path):
                makedirs(dst_path)
            # end if

            for file_name in file_names:
                file_ext = file_name.rsplit('.', 1)[-1]

                if file_ext == 'py':
                    self.filterFileByPath(join(src_path, file_name), join(dst_path, file_name))
                # end if
            # end for

            if not recursive:
                break
            # end if
        # end for
    # end def filterDir

    def filterFile(self, src_file, dst_file):
        """
        Filter a python file

        @param src_file [in] (str,stream) python docstring style file
        @param dst_file [in] (str,stream) doxygen comment style file
        """
        src_fo = (isinstance(src_file, str) and open(src_file, 'r')) or None
        dst_fo = (isinstance(dst_file, str) and open(dst_file, 'w+')) or None

        self.filterFileByStream(src_fo or src_file, dst_fo or dst_file)

        if src_fo:
            src_fo.close()
        # end if

        if dst_fo:
            dst_fo.close()
        # end if
    # end def filterFile

    def filterFileByPath(self, src_path, dst_path):
        """
        Filter a python file (path parameters)

        @param  src_path [in] (stream) python docstring style input filename
        @param  dst_path [in] (stream) doxygen comment style output filename
        """
        src_fo = open(src_path, 'r')
        dst_fo = open(dst_path, 'w+')
        p2c_fo = open(dst_path + '.p2c', 'w+')

        self.filterFileByStream(src_fo, dst_fo, p2c_fo, src_path, dst_path)

        src_fo.close()
        dst_fo.close()
        p2c_fo.close()
    # end def filterFileByPath

    def filterFileByStream(self, src_fo, dst_fo, p2c_fo=None, src_path=None, dst_path=None):
        """
        Filter a python file (stream parameters)

        @param src_fo   [in] (stream) python docstring style input stream
        @param dst_fo   [in] (stream) doxygen comment style output stream
        @param p2c_fo   [in] (stream) p2c output stream
        @param src_path [in] (str) Source file path
        @param dst_path [in] (str) Destination file path
        """
        (dox, p2c) = self._copydocreplacer(src_fo.readlines())

        dst_fo.write('\n'.join(dox))
        dst_fo.write(f'\n# Generated by {self._NAME} v {self._VERSION} on {strftime("%Y/%m/%d at %H:%M:%S")}\n')

        if p2c_fo is not None:
            dump((src_path, dst_path, p2c), p2c_fo)
        # end if
    # end def filterFileByStream

    __RE_WARN_FORMAT = re.compile(r'(.+):(\d+):(.*)', re.DOTALL)

    def warnify(self, log_file):
        """
        Update line number with source one

        @param log_file [in] (str) WARN_LOGFILE

        @warning WARN_FORMAT = "$file:$line: $text"
        """
        fo = open(log_file, 'r+')
        a_warning = fo.readlines()
        fo.close()

        src = ''

        for i_warning, v_warning in enumerate(a_warning):

            mo = self.__RE_WARN_FORMAT.match(v_warning)
            if mo is None:
                continue
            # end if

            src_path = None
            dst_path = None
            p2c = None
            if src != mo.group(1):
                src = mo.group(1)
                if exists(src + '.p2c'):
                    fo = open(src + '.p2c')
                    src_path, dst_path, p2c = load(fo)
                    fo.close()
                else:
                    src_path, dst_path, p2c = src, src, {}
                # end if
            # end if
            assert (normpath(src) == normpath(dst_path)), ValueError(
                    f'warning path inconsistent with .p2c contents:\n{src}\n{dst_path}')

            line_no = int(mo.group(2))
            a_warning[i_warning] = f'{src_path}:{p2c.get(line_no, line_no)}:{mo.group(3).replace("::", ".")}'
        # end for

        fo = open(log_file, 'w+')
        fo.writelines(a_warning)
        fo.close()
    # end def warnify

    _LINE_COPYDOC = re.compile(r'(\s*)@copydoc\s+([^\s]+)(.*)$')

    def _copydocreplacer(self, a_python):  # pylint:disable=R0912,R0915
        """
        Convert Python docstring into Doxygen comment

        @param a_python [in] (list) Python doscstring style

        @return (list) Doxygen comment style
        """

        new_lines = []
        p2c = {}
        for line_no, line in enumerate(a_python):
            line = line.rstrip('\n')
            re_match = self._LINE_COPYDOC.match(line)
            if re_match:
                groups = re_match.groups()
                prefix = groups[0]
                target = groups[1]
                aliases = [x for x in groups[2].strip().split(' ') if len(x)]
                aliases = dict([group.split('=', 1) for group in aliases if group is not None])

                # Replace the target package::module::class:: with package.module.class
                target = target.replace('::', '.')

                # Lookup the target in the pythonpath
                try:
                    target = importFqn(target)

                    # Handle any space prefix to the @copydoc target, by replacing
                    # the corresponding spaces by the current prefix
                    new_line = target.__doc__.lstrip('\n').rstrip() + '\n'
                    count = 0
                    for c in new_line.lstrip('\n'):
                        if c == ' ':
                            count += 1
                        else:
                            break
                        # end if
                    # end for

                    # Convert the target indentation to the copydoc line's one.
                    local_new_lines = []
                    for il in new_line.split('\n'):
                        if il.strip() == "":
                            local_new_lines.append(prefix)
                        elif il.startswith(' ' * count):
                            local_new_lines.append(prefix + il[count:].encode("string_escape"))
                        else:
                            local_new_lines.append(prefix + il.lstrip().encode("string_escape"))
                        # end if
                    # end for

                    line = '\n'.join(local_new_lines) + '\n'

                    # Handle aliases
                    for source, target in aliases.items():
                        if len(target):
                            line = re.sub(f'(@param\\s+){source}',
                                          f"\\1{target}",
                                          line)
                            line = re.sub(f'(@option\\s+){source}',
                                          f"\\1{target}",
                                          line)
                        else:
                            line = re.sub(f'(@param\\s+){source}',
                                          f"Obsolete: {target}",
                                          line)
                            line = re.sub(f'(@option\\s+){source}',
                                          f"Obsolete: {target}",
                                          line)
                        # end if
                    # end for

                    sub_lines, _ = self._copydocreplacer(line.split('\n'))
                    line = '\n'.join(sub_lines)
                except ImportError as _:
                    pass
                except AttributeError as _:
                    pass
                # end try
            # end if

            for new_line in line.split('\n'):
                new_lines.append(new_line)
                p2c[line_no + 1] = len(new_line)
            # end for
        # end for

        return new_lines, p2c
    # end def _copydocreplacer
# end class Filter


class Main(Filter):
    """
    Program that replaces the copydoc statements of a python script by their
    target docstring
    """

    def __init__(self):
        """
        Constructor.

        Initializes member variables.
        """
        super(Main, self).__init__()

        self._src_file = None
        self._dst_file = None
        self._srcDir = None
        self._dstDir = None

        self._exclude = None
        self._recursive = False
        self._logFile = None

        self._parseArgs()

        if self._logFile is not None:
            self.warnify(self._logFile)

        elif self._srcDir is not None:
            self.filterDir(self._srcDir, self._dstDir,
                           self._exclude, self._recursive)
        else:
            self.filterFile(self._src_file, self._dst_file)
        # end if
    # end def __init__

    def _parseArgs(self):  # pylint:disable=R0912
        """
        Parses the program arguments
        """

        parser = ArgumentParser(description=self._BRIEF, epilog=f'\n{self._NAME} v {self._VERSION}')
        parser.add_argument('--version', action='version', version=self._VERSION)

        parser.add_argument('-o', '--output',
                            metavar='FILE',
                            help='write output to FILE',
                            dest='output')

        parser.add_argument('-r', '--recursive',
                            help='process directories recursively',
                            action='store_true',
                            dest='recursive',
                            default=False)

        parser.add_argument('-e', '--exclude',
                            metavar='PATTERN',
                            help='exclude PATTERN from SRC directory',
                            action='append',
                            dest='exclude',
                            default=[])

        parser.add_argument('-w', '--warn',
                            metavar='LOGFILE',
                            help='update line number in Doxygen log file',
                            dest='logFile')

        # positional arguments
        parser.add_argument('files', nargs='+', metavar='FILES', help='pass one or more files')

        args = parser.parse_intermixed_args()

        if args.logFile is not None:
            self._logFile = args.logFile

            if not isfile(self._logFile):
                parser.error(f'{basename(self._logFile)}: expected regular file as output WARN_LOGFILE')
            # end if
            return
        # end if

        if args.output is None:
            self._dst_file = sys.stdout
        else:
            self._dst_file = args.output

            if exists(self._dst_file) and not isfile(self._dst_file):
                parser.error(f'{basename(self._dst_file)}: expected regular file as output FILE')
            # end if
        # end if

        self._recursive = args.recursive
        self._exclude = args.exclude

        # Arguments
        if len(args.files) == 0:
            self._src_file = sys.stdin

        elif len(args.files) == 1:
            self._src_file = abspath(args.files[0])
            if not isfile(self._src_file):
                parser.error(f'{basename(self._src_file)}: expected regular file as input FILE')
            # end if

        elif len(args.files) == 2:
            self._srcDir = abspath(args.files[0])

            if not exists(self._srcDir):
                parser.error(f'{basename(self._srcDir)}: directory not found as SRC')
            # end if

            if not isdir(self._srcDir):
                parser.error(f'{basename(self._srcDir)}: expected directory as SRC')
            # end if

            self._dstDir = abspath(args.files[1])

            if self._dstDir == self._srcDir:
                parser.error(f'{basename(self._dstDir)}: SRC and DST directories are the same')
            # end if

            if exists(self._dstDir) and not isdir(self._dstDir):
                parser.error(f'{basename(self._dstDir)}: expected directory as DST')
            # end if

        else:
            parser.error('too many parameters')
        # end if
    # end def _parseArgs
# end class Main


if __name__ == '__main__':
    Main()
# end if

# ----------------------------------------------------------------------------
# END OF FILE
# ----------------------------------------------------------------------------
