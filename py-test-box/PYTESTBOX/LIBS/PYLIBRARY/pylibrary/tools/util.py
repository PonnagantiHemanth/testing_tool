#!/usr/bin/env python
# -*- coding: utf-8 -*-
# ------------------------------------------------------------------------------
# Python Test Harness
# ------------------------------------------------------------------------------
"""
:package: pylibrary.tools.util
:brief: Test utilities module
:author: Christophe Roquebert <croquebert@logitech.com>
:date: 2018/11/06
"""
# ------------------------------------------------------------------------------
# imports
# ------------------------------------------------------------------------------
import copy
import warnings
from enum import auto
from enum import Enum
from enum import EnumMeta
from random import choice
from random import randint
from random import sample
from random import shuffle

from pylibrary.tools.hexlist import HexList
from pylibrary.tools.numeral import Numeral


# ------------------------------------------------------------------------------
# implementation
# ------------------------------------------------------------------------------
def computeWrongRange(value, light=False, rangeSize=None, minValue=None, maxValue=None):
    """
    Deprecated function. See ``compute_wrong_range``.

    :param value: Valid Value
    :type value: ``int`` or ``HexList`` or ``str`` or ``list``
    :param light: Light mode with less returned values - OPTIONAL
    :type light: ``bool``
    :param rangeSize: Limit max number of values in the range - OPTIONAL
    :type rangeSize: ``int`` or ``None``
    :param minValue: Min value of the wrong range - OPTIONAL
    :type minValue: ``int`` or ``None``
    :param maxValue: Max value of the wrong range - OPTIONAL
    :type maxValue: ``int`` or ``None``

    :return: Range of wrong values based on value
    :rtype: ``list[int]`` or ``list[HexList]`` or ``list[str]``
    """
    warnings.warn(
        'This function is deprecated, use compute_wrong_range() instead', DeprecationWarning)

    return compute_wrong_range(value, light=light, range_size=rangeSize, min_value=minValue, max_value=maxValue)
# end def computeWrongRange


def compute_wrong_range(value, light=False, range_size=None, min_value=None, max_value=None):
    """
    Compute a range of values including inverse bit of 'value' and typical wrong
    values

    Many types are supported for 'value' parameter:

    - int, str, HexList:
        The computed range include values which are generated by inversion of
        each bits of ``value`` and typical wrong values

    - list:
        The computed range include external bounds inside 'value' and typical
        wrong values
        example::

            value = [i, i+1, j, j+1, j+2]
            wrong_range = [i-1, i+2, j-1, j+3]

    .. note:: Typical wrong values depends on length of ``value`` or maximum element
        of ``value`` if ``value`` is a list.
        example::

            value = 8
            wrong_range = [0, 7, 9, 0x7F, 0x80, 0x81, 0xFF]
            value = "1111"
            wrong_range = [0, 0x1110, 0x1112, 0x7FFF, 0x8000, 0x8001, 0xFFFF]

    :param value: Valid Value
    :type value: ``int`` or ``HexList`` or ``str`` or ``list``
    :param light: Light mode with less returned values - OPTIONAL
    :type light: ``bool``
    :param range_size: Limit max number of values in the range - OPTIONAL
    :type range_size: ``int`` or ``None``
    :param min_value: Min value of the wrong range - OPTIONAL
    :type min_value: ``int`` or ``None``
    :param max_value: Max value of the wrong range - OPTIONAL
    :type max_value: ``int`` or ``None``

    :return: Range of wrong values based on value
    :rtype: ``list[int]`` or ``list[HexList]`` or ``list[str]``

    :raise ``Exception``: If ``range_size`` is less than or equal to 0
    :raise ``TypeError``: If ``value`` type is not (``int`` or ``str`` or ``HexList`` or ``list``)
    """
    wrong_range = []
    default_limited_wrong_range = []

    list_class = (value.__class__ == list)

    if (range_size is not None) and (range_size <= 0):
        raise Exception("Invalid value for range_size parameter: '%s'" % str(range_size))
    # end if

    if not list_class:

        if type(value) is str:
            hex_value = HexList(value)
        elif type(value) is int:
            hex_value = HexList().fromLong(value, None)
        elif type(value) is HexList:
            hex_value = value[:]
        else:
            raise TypeError("Unsupported type: %s" % type(value))
        # end if
        if not light:
            for pos in range(len(hex_value) * 8):
                wrong_value = hex_value.copy()
                wrong_value.invertBit(pos)
                if value_in_range(wrong_value.toLong(), min_value, max_value):
                    wrong_range.append(wrong_value.toLong())
                # end if
            # end for
        else:
            for pos_word in range(len(hex_value) * 2):
                wrong_value = hex_value.copy()
                pos = randint(0, 3) + (pos_word * 4)
                wrong_value.invertBit(pos)
                if value_in_range(wrong_value.toLong(), min_value, max_value):
                    wrong_range.append(wrong_value.toLong())
                # end if
            # end for
        # end if

        # Typical wrong values
        if max_value is None:
            hex_max_value = HexList("FF" * len(hex_value))
            max_value = hex_max_value.toLong()
        else:
            hex_max_value = HexList(Numeral(max_value))
        # end if

        if min_value is None:
            min_value = 0x00
        # end if

        default_wrong_range = [min_value,
                               max_value // 2,
                               max_value // 2 + 1,
                               max_value // 2 + 2,
                               max_value]

        if hex_value.toLong() != min_value:
            default_wrong_range.append(hex_value.toLong() - 1)

            default_limited_wrong_range.append(hex_value.toLong() - 1)
            default_limited_wrong_range.append(min_value)
        # end if

        if hex_value != hex_max_value:
            default_wrong_range.append(hex_value.toLong() + 1)

            default_limited_wrong_range.append(hex_value.toLong() + 1)
            default_limited_wrong_range.append(max_value)
        # end if

        for wrong_value in default_wrong_range:
            if ((wrong_value != hex_value.toLong())
                    and (wrong_value not in wrong_range)
                    and value_in_range(wrong_value, min_value, max_value)):
                wrong_range.append(wrong_value)
            # end if
        # end for

        if (range_size is not None) and (len(wrong_range) > range_size):
            # If range size is 1, keep only 1 value in default wrong range
            if range_size == 1:
                wrong_range = [choice(default_limited_wrong_range)]
            # end if

            # If range size >= 2:
            #  - Ensure we return at least value-1, value+1, min, and max value if possible
            #  - Add random values taken from wrong_range defined previously
            elif range_size >= 2:
                tmp_range = []
                shuffle(default_limited_wrong_range)
                while (len(tmp_range) < range_size) and (len(default_limited_wrong_range) > 0):
                    tmp_value = default_limited_wrong_range.pop()
                    if tmp_value not in tmp_range:
                        tmp_range.append(tmp_value)
                    # end if
                # end while

                shuffle(wrong_range)
                while (len(tmp_range) < range_size) and (len(wrong_range) > 0):
                    tmp_value = wrong_range.pop()
                    if tmp_value not in tmp_range:
                        tmp_range.append(tmp_value)
                    # end if
                # end while

                wrong_range = tmp_range
            # end if
        # end if

    else:
        # List class
        # ----------

        copy_value = copy.copy(value)
        copy_value = sorted(copy_value)

        if max_value is None:
            hex_max_value = HexList(copy_value[-1])
            hex_max_value = HexList("FF" * len(hex_max_value))
            max_value = hex_max_value.toLong()
        # end if

        # Compute of external bornes values
        for wrong_value in range(max_value):

            # Minimum borne
            if ((wrong_value not in copy_value)
                    and (wrong_value + 1 in copy_value)
                    and (wrong_value not in wrong_range)
                    and value_in_range(wrong_value, min_value, max_value)):
                wrong_range.append(wrong_value)
            # end if

            # Maximum borne
            if ((wrong_value not in copy_value)
                    and (wrong_value - 1 in copy_value)
                    and (wrong_value not in wrong_range)
                    and value_in_range(wrong_value, min_value, max_value)):
                wrong_range.append(wrong_value)
            # end if
        # end for

        if min_value is None:
            min_value = 0x00
        # end if

        # Typical wrong values
        default_wrong_range = [min_value,
                               max_value // 2,
                               max_value // 2 + 1,
                               max_value // 2 + 2,
                               max_value]

        for wrong_value in default_wrong_range:
            if ((wrong_value not in copy_value)
                    and (wrong_value not in wrong_range)
                    and value_in_range(wrong_value, min_value, max_value)):
                wrong_range.append(wrong_value)
            # end if
        # end for

        # If a range size is defined, shuffle the list and keep only 'x' first elements
        if (range_size is not None) and (len(wrong_range) > range_size):
            shuffle(wrong_range)
            while len(wrong_range) > range_size:
                wrong_range.pop()
            # end while
        # end if
    # end if

    # Typing of element with original value's type
    typed_wrong_range = []
    for elt in wrong_range:
        if type(value) is str:
            typed_wrong_range.append(str(HexList.fromLong(elt, len(value) / 2)))
        elif type(value) is HexList:
            typed_wrong_range.append(HexList.fromLong(elt, len(value)))
        else:
            typed_wrong_range.append(elt)
        # end if
    # end for

    return sorted(typed_wrong_range)
# end def compute_wrong_range


def computeWrongSizes(value):
    """
    Deprecated function. See ``compute_wrong_sizes``.

    :param  value: Value to re-size
    :type value: ``int`` or ``str`` or ``HexList`` or ``list``

    :return: List of re-sized values based on 'value' keeping its type
    :rtype: ``list[int]`` or ``list[HexList]`` or ``list[str]``
    """
    warnings.warn(
        'This function is deprecated, use compute_wrong_sizes() instead', DeprecationWarning)

    return compute_wrong_sizes(value)
# end def computeWrongSizes


def compute_wrong_sizes(value):
    """
    Build apparent values with different size

    Many types are supported for ``value`` parameter:

    - int, str, HexList, list:
      The computed range include values which are generated by suppression or
      adding of element in ``value``

    .. note::   A limitation is applied by adding only 1 element in the re-sized value
            example::

             value = [1, 2, 3]
             wrong_sizes = [ [], [1], [1, 2], [1, 2, 3, 0] ]

    :param  value: Value to re-size
    :type value: ``int`` or ``str`` or ``HexList`` or ``list``

    :return: List of re-sized values based on ``value`` keeping its type
    :rtype: ``list[int]`` or ``list[HexList]`` or ``list[str]``

    :raise ``TypeError``: If ``value`` type is not (``int`` or ``str`` or ``HexList`` or ``list``)
    """
    wrong_sizes = [HexList()]

    if type(value) is str:
        hex_value = HexList(value)
    elif type(value) is list:
        hex_value = HexList(value)
    elif type(value) is int:
        hex_value = HexList().fromLong(value, None)
    elif type(value) is HexList:
        hex_value = value[:]
    else:
        raise TypeError("Unsupported type: %s" % type(value))
    # end if

    # Decrease the size of the value
    for length in range(len(hex_value)):
        wrong_value = hex_value.copy()
        del wrong_value[0: length]
        wrong_sizes.append(wrong_value)
    # end for

    # Increase the size of the value
    wrong_sizes.remove(hex_value)
    hex_value.append(0x00)
    wrong_sizes.append(hex_value)

    # Typing of element with original value's type
    typed_wrong_sizes = []
    for elt in wrong_sizes:
        if type(value) is int:
            if elt != HexList():
                typed_wrong_sizes.append(elt.toLong())
            # end if
        elif type(value) is str:
            if elt != HexList():
                typed_wrong_sizes.append(str(HexList(elt)))
            else:
                typed_wrong_sizes.append("")
            # end if
        else:
            typed_wrong_sizes.append(elt)
        # end if
    # end for

    return sorted(typed_wrong_sizes)
# end def compute_wrong_sizes


def computeInfValues(value, isEqual=False):
    """
    Deprecated function. See ``compute_inf_values``.

    :param  value: Value to compare
    :type value: ``int`` or ``HexList`` or ``list``
    :param  isEqual: Included equal value - OPTIONAL
    :type isEqual: ``bool``

    :return: List of values <  'value' keeping its type
    :rtype: ``list[int]`` or ``list[HexList]``
    """
    warnings.warn(
        'This function is deprecated, use compute_inf_values() instead', DeprecationWarning)

    return compute_inf_values(value, is_equal=isEqual)
# end def computeInfValues


def compute_inf_values(value, is_equal=False):
    """
    Build a list of values inferior to a ``value``

    Many types are supported for 'value' parameter:

    - int, str, HexList, list:
      The computed list include special values

    .. note::

        example::

            B = [ 50 , 80 , FA , 03 ]

            to test A < B

            inf_list = [ list<A> ]

            where :

            A = B (if is_equal)

            A = B with 1 bit set to 1 put it to 0

            A = [ 00 , 00 , 00 , 00 ]
            A = [ 00 , 00 , 00 , 03 ]
            A = [ 00 , 00 , FA , 03 ]
            A = [ 00 , 80 , FA , 03 ]

            A = [ 4F , 80 , FA , 03 ]
            A = [ 50 , 7F , FA , 03 ]
            A = [ 50 , 80 , F9 , 03 ]
            A = [ 50 , 80 , FA , 02 ]

            A = [ 4F , FF , FF , FF ]
            A = [ 50 , 7F , FF , FF ]
            A = [ 50 , 80 , F9 , FF ]

            A = [ 50 , 00 , 00 , 00 ]
            A = [ 50 , 80 , 00 , 00 ]
            A = [ 50 , 80 , FA , 00 ]


    :param  value: Value to compare
    :type value: ``int`` or ``HexList`` or ``list``
    :param  is_equal: Included equal value - OPTIONAL
    :type is_equal: ``bool``

    :return: List of values <  ``value`` keeping its type
    :rtype: ``list[int]`` or ``list[HexList]`` or ``list[str]``

    :raise ``TypeError``: If ``value`` type is not (``int`` or ``str`` or ``HexList`` or ``list``)
    """
    if type(value) is str:
        hex_value = HexList(value)
    elif type(value) is list:
        hex_value = HexList(value)
    elif type(value) is int:
        hex_value = HexList().fromLong(value, None)
    elif type(value) is HexList:
        hex_value = value[:]
    else:
        raise TypeError("Unsupported type: %s" % type(value))
    # end if

    # Init
    inf_list = [hex_value]

    # Min value
    new_value = hex_value.copy()
    for pos in range(len(hex_value)):
        new_value[pos] = 0x00
    # end for
    inf_list.append(new_value)

    # Decrement 1 to each byte in value
    for pos in range(len(hex_value)):
        new_value = hex_value.copy()
        if new_value[pos] != 0x00:
            new_value[pos] -= 1
            inf_list.append(new_value)
        # end if
    # end for

    # Decrement 1 to each byte and other LSB bytes set 0xFF in value
    for pos in range(len(hex_value)):
        new_value = hex_value.copy()
        if new_value[pos] != 0x00:
            new_value[pos] -= 1
            for pos1 in range(pos + 1, len(hex_value)):
                new_value[pos1] = 0xFF
            # end for
            inf_list.append(new_value)
        # end if
    # end for

    # Set to 0x00 each byte in value
    for pos in range(len(hex_value)):
        new_value = hex_value.copy()
        if new_value[pos] != 0x00:
            new_value[pos] = 0x00
            inf_list.append(new_value)
        # end if
    # end for

    # Lsb bytes set to 0x00 in value
    for pos in range(len(hex_value)):
        new_value = hex_value.copy()
        for pos1 in range(pos + 1, len(hex_value)):
            new_value[pos1] = 0x00
        # end for
        inf_list.append(new_value)
    # end for

    # Set to 0 each bit set to 1 in value
    for pos in range(len(hex_value) * 8):
        new_value = hex_value.copy()
        if new_value.testBit(pos):
            new_value.clearBit(pos)
            inf_list.append(new_value)
        # end if
    # end for

    # Suppress double
    inf_list1 = []
    for elt in inf_list:
        if elt not in inf_list1:
            inf_list1.append(elt)
        # end if
    # end for

    # Suppress the original value ?
    if not is_equal:
        inf_list1.remove(hex_value)
    # end if

    # Typing of element with original value's type
    typed_inf_values = []
    for elt in inf_list1:
        if type(value) is int:
            typed_inf_values.append(elt.toLong())
        elif type(value) is str:
            typed_inf_values.append(str(HexList(elt)))
        else:
            typed_inf_values.append(elt)
        # end if
    # end for

    return sorted(typed_inf_values)
# end def compute_inf_values


def computeSupValues(value, isEqual=False):
    """
    Deprecated function. See ``compute_sup_values``.

    :param  value: Value to compare
    :type value: ``int`` or ``HexList`` or ``list``
    :param  isEqual: Included equal value - OPTIONAL
    :type isEqual: ``bool``

    :return: (list) List of values >  ``value`` keeping its type
    :rtype: ``list[int]`` or ``list[HexList]`` or ``list[str]``
    """

    warnings.warn(
        'This function is deprecated, use compute_sup_values() instead', DeprecationWarning)

    return compute_sup_values(value, is_equal=isEqual)
# end def computeSupValues


def compute_sup_values(value, is_equal=False):
    """
    Build a list of values superior to a ``value``

    Many types are supported for 'value' parameter:

    - int, str, HexList, list:
      The computed list include special values

    .. note::
        example::

            B = [ 50 , 80 , FA , 03 ]

            to test A > B

            sup_list = [ list<A> ]

            where :

            A = B (if is_equal)

            A = B with 1 bit set to 0 put it to 1

            A = [ FF , 80 , FA , 03 ]
            A = [ FF , FF , FA , 03 ]
            A = [ FF , FF , FF , 03 ]
            A = [ FF , FF , FF , FF ]

            A = [ 51 , 80 , FA , 03 ]
            A = [ 50 , 81 , FA , 03 ]
            A = [ 50 , 80 , FB , 03 ]
            A = [ 50 , 80 , FA , 04 ]

            A = [ 51 , 00 , 00 , 00 ]
            A = [ 50 , 81 , 00 , 00 ]
            A = [ 50 , 80 , FB , 00 ]

            A = [ 50 , FF , FF , FF ]
            A = [ 50 , 80 , FF , FF ]
            A = [ 50 , 80 , FA , FF ]


    :param  value: Value to compare
    :type value: ``int`` or ``HexList`` or ``list``
    :param  is_equal: Included equal value - OPTIONAL
    :type is_equal: ``bool``

    :return: (list) List of values >  ``value`` keeping its type
    :rtype: ``list[int]`` or ``list[HexList]`` or ``list[str]``

    :raise ``TypeError``: If ``value`` type is not (``int`` or ``str`` or ``HexList`` or ``list``)
    """
    if type(value) is str:
        hex_value = HexList(value)
    elif type(value) is list:
        hex_value = HexList(value)
    elif type(value) is int:
        hex_value = HexList().fromLong(value, None)
    elif type(value) is HexList:
        hex_value = value[:]
    else:
        raise TypeError("Unsupported type: %s" % type(value))
    # end if

    # Init
    sup_list = [hex_value]

    # Max value
    new_value = hex_value.copy()
    for pos in range(len(hex_value)):
        new_value[pos] = 0xFF
    # end for
    sup_list.append(new_value)

    # Increment 1 to each byte in value
    for pos in range(len(hex_value)):
        new_value = hex_value.copy()
        if new_value[pos] != 0xFF:
            new_value[pos] += 1
            sup_list.append(new_value)
        # end if
    # end for

    # Increment 1 to each byte and other LSB bytes set 0x00 in value
    for pos in range(len(hex_value)):
        new_value = hex_value.copy()
        if new_value[pos] != 0xFF:
            new_value[pos] += 1
            for pos1 in range(pos + 1, len(hex_value)):
                new_value[pos1] = 0x00
            # end for
            sup_list.append(new_value)
        # end if
    # end for

    # Set to 0xFF each byte in value
    for pos in range(len(hex_value)):
        new_value = hex_value.copy()
        if new_value[pos] != 0xFF:
            new_value[pos] = 0xFF
            sup_list.append(new_value)
        # end if
    # end for

    # Lsb bytes set to 0xFF in value
    for pos in range(len(hex_value)):
        new_value = hex_value.copy()
        for pos1 in range(pos + 1, len(hex_value)):
            new_value[pos1] = 0xFF
        # end for
        sup_list.append(new_value)
    # end for

    # Set to 1 each bit set to 0 in value
    for pos in range(len(hex_value) * 8):
        new_value = hex_value.copy()
        if not new_value.testBit(pos):
            new_value.setBit(pos)
            sup_list.append(new_value)
        # end if
    # end for

    # Suppress double
    sup_list1 = []
    for elt in sup_list:
        if elt not in sup_list1:
            sup_list1.append(elt)
        # end if
    # end for

    # Suppress the original value ?
    if not is_equal:
        sup_list1.remove(hex_value)
    # end if

    # Typing of element with original value's type
    typed_sup_values = []
    for elt in sup_list1:
        if type(value) is int:
            typed_sup_values.append(elt.toLong())
        elif type(value) is str:
            typed_sup_values.append(str(HexList(elt)))
        else:
            typed_sup_values.append(elt)
        # end if
    # end for

    return sorted(typed_sup_values)
# end def compute_sup_values


def computeMapValues(value):
    """
    Deprecated function. See ``compute_map_values``.

    :param  value: Reference Value
    :type value: ``int`` or ``HexList`` or ``list``

    :return: List of tuples with 'value' in (minBound, bitstruct)
    :rtype: ``list[int]`` or ``list[HexList]``
    """

    warnings.warn(
        'This function is deprecated, use compute_map_values() instead', DeprecationWarning)

    return compute_map_values(value)
# end def computeMapValues


def compute_map_values(value):
    """
    Build a list of values and bitstruct to involve a ``value``

    Many types are supported for ``value`` parameter:

    - int, HexList, list:
      The computed list include special values

    .. note::
        example::

            B = [ 50 , 80 ]

            to test B is in [Value, bitstruct]

            mapList = [ list<minBound, bitstruct> ]

            where :

            ( minBound = [ 50 , 80 ], bitstruct = [80 , 00 ] )
            ( minBound = [ 50 , 7F ], bitstruct = [C0 , 00 ] )
            ( minBound = [ 50 , 79 ], bitstruct = [81 , 00 ] )
            ( minBound = [ 50 , 78 ], bitstruct = [80 , 80 ] )
            ( minBound = [ 50 , 71 ], bitstruct = [80 , 01 ] )

            ( minBound = [ 50 , 80 ], bitstruct = [FF , FF ] )
            ( minBound = [ 50 , 71 ], bitstruct = [FF , FF ] )


    :param  value: Reference Value
    :type value: ``int`` or ``HexList`` or ``list``

    :return: List of tuples with 'value' in (minBound, bitstruct)
    :rtype: ``list[int]`` or ``list[HexList]``

    :raise ``TypeError``: If ``value`` type is not (``int`` or ``HexList`` or ``list``)
    """
    if type(value) is list:
        hex_value = HexList(value)
    elif type(value) is int:
        hex_value = HexList().fromLong(value, None)
    elif type(value) is HexList:
        hex_value = value[:]
    else:
        raise TypeError("Unsupported type: %s" % type(value))
    # end if

    # Init
    map_list = []

    # Build a Reference Bitmap
    map_ref = hex_value.copy()
    for pos in range(len(hex_value)):
        map_ref[pos] = 0x00
    # end for
    map_ref[0] = 0x80

    # Build Value with the reference bitstruct
    new_value = hex_value.copy()
    map_list.append((new_value, map_ref))

    # Decrement value and build corresponding bitstruct
    for pos in range(1, len(hex_value) * 8):
        new_value = hex_value.copy()
        bitstruct = map_ref[:]
        int_value = new_value.toLong()
        if new_value > 0:
            bitstruct = HexList(Numeral((bitstruct.toLong() >> pos), len(hex_value)))
            bitstruct[0] = bitstruct[0] | 0x80
            int_value -= pos
            map_list.append((HexList(Numeral(int_value)), bitstruct))
        # end if
    # end for

    # Build a Bitmap = FF .. FF
    bitstruct = map_ref[:]
    for pos in range(len(hex_value)):
        bitstruct[pos] = 0xFF
    # end for

    # Build original value with a bitstruct = FF FF .. FF
    new_value = hex_value.copy()
    map_list.append((new_value, bitstruct))

    # Build extreme value with a bitstruct = FF FF .. FF
    new_value = hex_value.copy()
    int_value = new_value.toLong()
    int_value = int_value - ((len(hex_value) * 8) - 1)
    map_list.append((HexList(Numeral(int_value)), bitstruct))

    return sorted(map_list)
# end def compute_map_values


def computeBadMapValues(value):
    """
    Deprecated function. See ``compute_bad_map_values``.

    :param  value: Reference Value
    :type value: ``int`` or ``HexList`` or ``list``

    :return: List of tuples with 'value' NOT in (minBound, bitstruct)
    :rtype: ``list[int]`` or ``list[HexList]``
    """
    warnings.warn(
        'This function is deprecated, use compute_bad_map_values() instead', DeprecationWarning)

    return compute_bad_map_values(value)
# end def computeBadMapValues


def compute_bad_map_values(value):
    """
    Build a list of values and bitstruct to NOT involve a ``value``

    Many types are supported for ``value`` parameter:

    - int, HexList, list:
      The computed list include special values

    .. note::
        example::

            B = [ 50 , 80 ]

            to test B is NOT in [Value, bitstruct]

            mapList = [ list<minBound, bitstruct> ]

            where :

            ( minBound = [ 50 , 7F ], bitstruct = [BF , FF ] )
            ( minBound = [ 50 , 79 ], bitstruct = [FE , FF ] )
            ( minBound = [ 50 , 78 ], bitstruct = [FF , 7F ] )
            ( minBound = [ 50 , 71 ], bitstruct = [FF , FE ] )

            ( minBound = [ 50 , 81 ], bitstruct = [FF , FF ] )
            ( minBound = [ 50 , 70 ], bitstruct = [FF , FF ] )


    :param  value: Reference Value
    :type value: ``int`` or ``HexList`` or ``list``

    :return: List of tuples with ``value`` NOT in (minBound, bitstruct)
    :rtype: ``list[int]`` or ``list[HexList]``

    :raise ``TypeError``: If ``value`` type is not (``int`` or ``HexList`` or ``list``)
    """
    if type(value) is list:
        hex_value = HexList(value)
    elif type(value) is int:
        hex_value = HexList().fromLong(value, None)
    elif type(value) is HexList:
        hex_value = value[:]
    else:
        raise TypeError("Unsupported type: %s" % type(value))
    # end if

    # Init
    map_list = []

    # Build a Reference Bitmap
    map_ref = hex_value.copy()
    for pos in range(len(hex_value)):
        map_ref[pos] = 0x00
    # end for
    map_ref[0] = 0x80

    # Decrement value and build a NOT corresponding bitstruct
    for pos in range(1, len(hex_value) * 8):
        new_value = hex_value.copy()
        bitstruct = map_ref[:]
        int_value = new_value.toLong()
        if new_value > 0:
            bitstruct = HexList(Numeral((bitstruct.toLong() >> pos), len(hex_value)))
            for ind in range(len(hex_value)):
                bitstruct[ind] ^= 0xFF
            # end for
            bitstruct[0] = bitstruct[0] | 0x80
            int_value -= pos
            map_list.append((HexList(Numeral(int_value)), bitstruct))
        # end if
    # end for

    # Build a Bitmap = FF .. FF
    bitstruct = map_ref[:]
    for pos in range(len(hex_value)):
        bitstruct[pos] = 0xFF
    # end for

    # Build original value + 1 with a bitstruct = FF FF .. FF
    new_value = hex_value.copy()
    int_value = new_value.toLong() + 1
    map_list.append((HexList(Numeral(int_value)), bitstruct))

    # Build more extreme value with a bitstruct = FF FF .. FF
    new_value = hex_value.copy()
    int_value = new_value.toLong()
    int_value = int_value - (len(hex_value) * 8)
    map_list.append((HexList(Numeral(int_value)), bitstruct))

    return sorted(map_list)
# end def compute_bad_map_values


def computeInvertedBitRange(value):
    """
    Deprecated function. See ``compute_inverted_bit_range``.

    :param  value: Valid Value
    :type value: ``HexList``

    :return: Range of inverted bits values based on value
    :rtype: ``list[HexList]``
    """

    warnings.warn(
        'This function is deprecated, use compute_inverted_bit_range() instead', DeprecationWarning)

    return compute_inverted_bit_range(value)
# end def computeInvertedBitRange


def compute_inverted_bit_range(value):
    """
    Compute a range of values including only all inverse bit of ``value``
    Only  HexList is supported for ``value`` parameter:

    - int, str, HexList:
        The computed range include values which are generated by inversion of
        each bits of ``value`` and all inverted bits value

    .. note::    We expect that the value length doesn't exceed 255 bytes
            example::
                value = "4E"
                inverted_bit_range = [0xCE,0x0E,0x6E,0x5E,0x46,0x4C,0x4F,0xB1]

    :param  value: Valid Value
    :type value: ``HexList``

    :return: Range of inverted bits values based on value
    :rtype: ``list[int]``

    :raise ``TypeError``: If ``value`` type is not ``HexList``
    :raise ``TypeError``: If ``value`` length is greater than 255
    """
    inverted_bit_range = []

    if type(value) is HexList:
        hex_value = value[:]
    else:
        raise TypeError("Unsupported type: %s" % type(value))
    # end if

    if len(value) not in list(range(1, 256)):
        raise TypeError("Unsupported length: %s > 255 bytes" % len(value))
    # end if

    for pos in range(len(hex_value) * 8):
        invert_value = hex_value.copy()
        invert_value.invertBit(pos)
        inverted_bit_range.append(invert_value.toLong())
    # end for

    inverted_bit_range.append((~invert_value).toLong())

    return sorted(inverted_bit_range)
# end def compute_inverted_bit_range


def valueInRange(value=None, minValue=None, maxValue=None):
    """
    Deprecated function. See ``value_in_range``.

    :param value: Value to check
    :type value: ``int``
    :param minValue: Min value to check - OPTIONAL
    :type minValue: ``int`` or ``None``
    :param maxValue: Max value to check - OPTIONAL
    :type maxValue: ``int`` or ``None``

    :return: Flag indicating if the value is in range
    :rtype:``bool``
    """

    warnings.warn(
        'This function is deprecated, use value_in_range() instead', DeprecationWarning)

    return value_in_range(value=value, min_value=minValue, max_value=maxValue)
# end def valueInRange


def value_in_range(value=None, min_value=None, max_value=None):
    """
    Return true or false depending on min_value and max_value
    If min value is not defined, check will be done only against max value
    If max value is not defined, check will be done only against min value
    If both are not defined, method will always return true.

    :param value: Value to check
    :type value: ``int``
    :param min_value: Min value to check - OPTIONAL
    :type min_value: ``int`` or ``None``
    :param max_value: Max value to check - OPTIONAL
    :type max_value: ``int`` or ``None``

    :return: Flag indicating if the value is in range
    :rtype:``bool``
    """

    if (min_value is None) and (max_value is None):
        return True
    elif (min_value is not None) and (max_value is not None):
        if min_value <= value <= max_value:
            return True
        else:
            return False
        # end if
    elif min_value is not None:
        if value >= min_value:
            return True
        else:
            return False
        # end if
    else:
        if value <= max_value:
            return True
        else:
            return False
        # end if
    # end if
# end def value_in_range


def uniquifyList(inputList):
    """
    Deprecated function. See ``uniquify_list``.

    :param  inputList: List with possible duplicated elements
    :type inputList: ``list``

    :return: List of unique elements
    :rtype: ``list``
    """

    warnings.warn(
        'This function is deprecated, use uniquify_list() instead', DeprecationWarning)

    return uniquify_list(inputList)
# end def uniquifyList


def uniquify_list(input_list):
    """
    Compute a list with unique elements in
    the input order is preserved

    :param  input_list: List with possible duplicated elements
    :type input_list: ``list``

    :return: List of unique elements
    :rtype: ``list``
    """

    output_list = []
    for e in input_list:
        if e not in output_list:
            output_list.append(e)
        # end if
    # end for
    return output_list
# end def uniquify_list


def maskValuesInList(inputList, mask, operand="and"):
    """
    Deprecated function. See ``mask_values_in_list``.

    :param  inputList: List with possible duplicated elements
    :type inputList: ``list``
    :param  mask: Mask to apply on the values in the list
    :type mask: ``int``
    :param  operand: Type of operation to apply on the mask - OPTIONAL
    :type operand: ``str``

    :return: List of unique elements
    :rtype: ``list``
    """

    warnings.warn(
        'This function is deprecated, use mask_values_in_list() instead', DeprecationWarning)

    return mask_values_in_list(inputList, mask, operand=operand)
# end def maskValuesInList


def mask_values_in_list(input_list, mask, operand="and"):
    """
    Compute a list with a mask passed in parameter and an operand

    :param  input_list: List with possible duplicated elements
    :type input_list: ``list``
    :param  mask: Mask to apply on the values in the list
    :type mask: ``int``
    :param  operand: Type of operation to apply on the mask - OPTIONAL
    :type operand: ``str``

    :return: List of unique elements
    :rtype: ``list``

    :raise ``ValueError``: if ``input_list`` is ``None`` or empty
    :raise ``ValueError``: if ``mask`` is ``None``
    :raise ``TypeError``: if not ``operand`` in [and, or, xor]
    """

    output_list = []
    if input_list is None or len(input_list) == 0:
        raise ValueError("list is None or empty")
    # end if
    if mask is None:
        raise ValueError("mask is not defined")
    # end if
    if not operand in ["and", "or", "xor"]:
        raise TypeError("Unsupported operand: %s choose among [and, or, xor]" %
                        operand)
    # end if

    for element in input_list:
        if operand == "and":
            output_list.append(element & mask)
        # end if
        if operand == "or":
            output_list.append(element | mask)
        # end if
        if operand == "xor":
            output_list.append(element ^ mask)
        # end if
    # end for
    return output_list
# end def mask_values_in_list


def choices(my_list, elem_nb=None):
    """
    Helper function to randomly select a subset of a list

    :param my_list: list of element
    :type my_list: ``list``
    :param elem_nb: number of element to choose - OPTIONAL
    :type elem_nb: ``int`` or ``None``

    :return: List of element randomly selected
    :rtype: ``list``
    """
    if elem_nb is None:
        elem_nb = randint(1, len(my_list))
    # end if
    return sample(my_list, elem_nb)
# end def choices


class NotImplementedAbstractMethodError(NotImplementedError):
    """
    Exception raised if a method has not been implemented in inheriting class
    """

    def __init__(self, message='This function should be implemented in inheriting class'):
        super().__init__(message)
    # end def __init__
# end class NotImplementedAbstractMethodError


class ContainsEnumMeta(EnumMeta):
    """
    Metaclass to add the possibility to use the ``in`` operation to an enumeration class.
    """
    def __contains__(cls, item):
        """
        Method for the ``in`` operation.

        :param item: Item to test
        :type item: ``object``

        :return: Flag indicating if the item is part of the enumeration
        :rtype: ``bool``
        """
        try:
            cls(item)
        except ValueError:
            return False
        else:
            return True
        # end try
    # end def __contains__
# end class ContainsEnumMeta


class ContainsIntEnumMeta(EnumMeta):
    """
    Metaclass exclusively for ``IntEnum`` to add the possibility to use the ``in`` operation to an enumeration class.
    This will work for an item in the enum, and the value or the name of the item in the enum. It will also add the
    possibility to call the enum to get an item using the name of the item (normally it just works with the item itself
    or the value of the item).
    """
    def __contains__(cls, item):
        """
        Method for the ``in`` operation.

        :param item: Item to test (it can be a name in the enum)
        :type item: ``str`` or ``int`` or ``cls``

        :return: Flag indicating if the item is part of the enumeration
        :rtype: ``bool``
        """
        if isinstance(item, cls):
            return True
        # end if

        if isinstance(item, int):
            try:
                cls(item)
            except ValueError:
                return False
            else:
                return True
            # end try
        # end if

        if isinstance(item, str):
            return item in cls._member_map_
        # end if

        return False
    # end def __contains__

    def __call__(cls, value, *args, **kwargs):
        # See ``EnumMeta.__call__``
        if isinstance(value, str):
            # If the value is a string, it represents the name of the item wanted
            return cls[value]
        # end if
        return super().__call__(value=value, *args, **kwargs)
    # end def __call__
# end class ContainsIntEnumMeta


def float_range(first, last=None, step=None):
    """
    This function generates a float range of numbers w/o using any library.

    :param first: First number in the range
    :type first: ``float``
    :param last: Last number in the range - OPTIONAL
    :type last: ``float`` or ``None``
    :param step: Step or the common difference - OPTIONAL
    :type step: ``float`` or ``None``

    :return: The list of float value in a Generator object
    :rtype: ``generator``
    """
    # Use float number in range() function
    # if last and step argument is null set first and last=0.0 and step = 1.0

    if last is None:
        last = first + 0.0
        first = 0.0
    # end if
    if step is None:
        step = 1.0
    # end if
    while True:
        if step > 0 and first >= last:
            break
        elif step < 0 and first <= last:
            break
        # end if
        yield "%g" % first  # return float number
        first += step
    # end while
# end float_range


def reverse_bits(input, int_size=8):
    """
    Given an integer, reverse its bit sequence.

    Sample Input:  00100110
    Sample Output: 01100100

    Technical Details:
      It is necessary to know whether the decimal number being passed as
      input is of type byte (8-bit) or short (16-bit) or int (32-bit) or
      long (64-bit).

    :param input: integer number to be reversed
    :type input: ``int``
    :param int_size: integer size in bit - OPTIONAL
    :type int_size: ``int``

    :return: Reversed integer
    :rtype: ``int``
    """
    output = 0
    for position in reversed(range(int_size)):
        output += ((input & 1) << position)
        input >>= 1
    # end for
    return output
# end def reverse_bits


class TwoWayDict(dict):
    """
    A dictionary that can be used in two ways: regular way and reverse (key-value) way. This means that you cannot
    have one key for multiple values.

    WARNING: DO NOT USE ANOTHER INIT METHOD THAN THE ONE WITHOUT ARGUMENT, IT COULD RESULT IN SOME UNEXPECTED BEHAVIOR.
    HERE IS AN EXAMPLE OF A PROPER USE:

    ```
    test = TwoWayDict()
    test[1] = 'one'
    test[2] = 'two'

    print(test[1])  # Result: one
    print(test[2])  # Result: two
    print(test['one'])  # Result: 1
    print(test['two'])  # Result: 2
    ```
    """

    def __setitem__(self, key, value):
        """
        Set a key/value pair. This will actually create two entries in the dictionary: key to value and value to key.
        Therefore, the key and value cannot have the same hash as it is what is used to retrieve elements in
        a dictionary.

        :param key: The key
        :type key: ``object``
        :param value: The value
        :type value: ``object``
        """
        assert hash(key) != hash(value), "Cannot have two objects with the same hash as key and value for TwoWayDict"

        # Remove any previous connections with these values
        if key in self:
            del self[key]
        # end if
        if value in self:
            del self[value]
        # end if
        dict.__setitem__(self, key, value)
        dict.__setitem__(self, value, key)
    # end def __setitem__

    def __delitem__(self, key):
        """
        Delete a key/value pair. This will actually delete the two entries in the dictionary: key to value and
        value to key.

        :param key: The key
        :type key: ``object``
        """
        dict.__delitem__(self, self[key])
        dict.__delitem__(self, key)
    # end def __delitem__

    def __len__(self):
        """
        Return the number of key/value pairs
        """
        return dict.__len__(self) // 2
    # end def __len__
# end class TwoWayDict


class UtilNonNumericEnum(Enum):
    """
    Enum containing some util values that would be used non numerically.

    For example, the first value is ``AUTO_FILL``: this will be used as an optional parameter value other than
    ``None`` to have default values for a parameter while ``None`` value deactivate the parameter.
    """
    AUTO_FILL = auto()
# end class UtilNonNumericEnum

# ------------------------------------------------------------------------------
# END OF FILE
# ------------------------------------------------------------------------------
